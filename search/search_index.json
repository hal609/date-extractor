{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"date-fuzz","text":""},{"location":"#date-fuzz-for-python","title":"date-fuzz for Python \ud83d\uddd3\ufe0f","text":""},{"location":"#what-is-date-fuzz","title":"What Is date-fuzz?","text":"<p>Lightweight Python package to fuzzy extract dates from a corpus of text.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install date_fuzz\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<pre><code>from date_fuzz import find_dates\n\ntext = \"A thing happened on Jan 1st 2012 and the next morning at 09:15 and also jan 15th at 12am in 2018.\"\ndates = find_dates(text)\nprint(dates)\n\n# Output\n[\n    ('2012-01-01', 4),\n    ('2012-01-02 09:15', 9),\n    ('2018-01-15 12:00', 15)\n]\n</code></pre>"},{"location":"modules/","title":"Modules","text":"<p>Returns a list of tuples comprising the located date and the word index at which it was found.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The corpus of text in which to find dates/times.</p> required <p>Returns:</p> Type Description <code>list[tuple[str, int]]</code> <p>list[tuple[str, int]]: A list of tuples containing a string representing the date and time and an integer word index at which it was found.</p> <p>Examples:</p> <p>Get dates from a text sample.</p> <pre><code>&gt;&gt;&gt; find_dates(\"A thing happened on Jan 1st 2012 and the next morning at 09:15 and also jan 15th at 12am in 2018.\")\n[\n    ('2012-01-01', 4),\n    ('2012-01-02 09:15', 9),\n    ('2018-01-15 12:00', 15)\n]\n</code></pre> Source code in <code>date_fuzz/extraction.py</code> <pre><code>def find_dates(text: str) -&gt; list[tuple[str, int]]:\n    \"\"\"Returns a list of tuples comprising the located date and the\n    word index at which it was found.\n\n    Args:\n        text (str): The corpus of text in which to find dates/times.\n\n    Returns:\n        list[tuple[str, int]]: A list of tuples containing a string\n            representing the date and time and an integer word index at\n            which it was found.\n\n    Examples:\n        Get dates from a text sample.\n\n        &gt;&gt;&gt; find_dates(\"A thing happened on Jan 1st 2012 and the next morning at 09:15 and also jan 15th at 12am in 2018.\")\n        [\n            ('2012-01-01', 4),\n            ('2012-01-02 09:15', 9),\n            ('2018-01-15 12:00', 15)\n        ]\n    \"\"\"\n    # Check for multiples of the same token\n    token_counts = {}\n    found_indicators = find_date_time_indicators(text)\n    if len(found_indicators) == 0:\n        return []\n\n    found_tokens = [indicator.token for indicator in found_indicators]\n    for entry in found_tokens:\n        token_counts[entry] = found_tokens.count(entry)\n\n    token_running_counts = {}\n    for token in token_counts:\n        token_running_counts[token] = 0\n\n    words = text.split()\n\n    tokens = []\n    located_positions = set()\n\n    for indicator in found_indicators:\n        token, token_type = indicator.token, indicator.time_type\n\n        for i, _w in enumerate(words):\n            # Skip previously matched entries to prevent collisions\n            if i in located_positions:\n                continue\n\n            # If the token has multiple words then check sequences of that number of words\n            num_words = token.count(\" \") + 1\n\n            # Although it looks like this will overflow the words list, python just handles trying to slice beyond the end\n            w_to_check = \" \".join(words[i : i + num_words])\n\n            # Strip extra characters to ensure indicators are located correctly in text recognition\n            w_to_check = w_to_check.replace(\".\", \"\")\n            w_to_check = w_to_check.replace(\",\", \"\")\n            # w_to_check = w_to_check.replace(\" \", \"\")\n\n            if token == w_to_check:\n                if token_running_counts[token] == token_counts[token]:\n                    break\n                token_running_counts[token] += 1\n                located_positions.add(i)\n                tokens.append(DateIndicator(token, i, token_type))\n                if token_running_counts[token] == token_counts[token]:\n                    break\n    groups = group_tokens(text, tokens)\n    formatted_groups = format_token_groups(groups)\n\n    return formatted_groups\n</code></pre> <p>Function to remove all date/time indicators from a text sample.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text block to strip.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Text block with dates/times removed.</p> <p>Examples:</p> <p>This can be used to get raw text once dates have been extracted.</p> <pre><code>&gt;&gt;&gt; strip_dates(\"Jan 1st 2012: A thing happened.\")\nA thing happened.\n</code></pre> Source code in <code>date_fuzz/extraction.py</code> <pre><code>def strip_dates(text: str) -&gt; str:\n    \"\"\"Function to remove all date/time indicators from a text sample.\n\n    Args:\n        text (str): Text block to strip.\n\n    Returns:\n        str: Text block with dates/times removed.\n\n    Examples:\n        This can be used to get raw text once dates have been extracted.\n\n        &gt;&gt;&gt; strip_dates(\"Jan 1st 2012: A thing happened.\")\n        A thing happened.\n    \"\"\"\n    stripped_text = deepcopy(text)\n    for pattern in date_time_patterns_dict:\n        stripped_text = pattern.sub(\"\", stripped_text)\n\n    stripped_text = stripped_text.replace(\"  \", \" \")\n    stripped_text = stripped_text.replace(\" ,\", \"\")\n    stripped_text = stripped_text.replace(\" :\", \"\")\n    stripped_text = stripped_text.replace(\" .\", \".\")\n    return stripped_text.replace(\"  \", \" \")\n</code></pre>"}]}